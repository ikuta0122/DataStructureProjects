算法分析
1.算法的时间复杂度分析
	1.1事后分析估算方法
		*System.currentTimeMillis()
			获得的是自1970-1-01 00:00:00.000 到当前时刻的毫秒总数,返回值类型为long
		*例子
			public static void main(String[] args) {
				long start = System.currentTimeMillis();
				int sum = 0;
				int n = 100;
				for (int i = 1; i <= n; i++) {
					sum += i;
				}
				System.out.println("sum=" + sum);
				long end = System.currentTimeMillis();
				System.out.println(start - end);
			}
		*缺点:必须依据算法实现编写好的测试程序,通常要花费大量的时间和精力.

	1.2事前分析估算方法
		程序在计算机上运行所消耗的时间取决于以下因素:
			*算法采用的策略和方案
			*编译产生的代码质量
			*问题的输入规模(所谓的输入规模就是输入量的多少)
			*机器执行指令的速度
		因此,程序在计算机上运行所消耗的时间依赖于算法的好坏和问题的输入规模.
		如果算法固定,那么程序在计算机上运行所消耗的时间就只和问题的输入规模有关系了.

2.算法的时间复杂度结论
	*结论1:算法函数中的的常数可以忽略
	*结论2:算法函数中的最高次幂的常数因子可以忽略
	*结论3:算法函数中n最高次幂越小,算法效率最高

3.大O记法
	3.1	基础:
		*算法的时间复杂度T(n) = O(f(n))
		*算法的空间复杂度S(n) = O(f(n))
		*f(n)是问题规模n的某个函数
		*结论:执行次数 = 执行时间
	3.2	规则:
		*用常数1取代所有加法常数
		*只保留最高阶项
		*最高次幂的常数因子设置为1
	3.3	常见的大O阶
		3.3.1常数阶	 O(1)
		3.3.2对数阶	 O(logn)
		3.3.3线性阶	 O(n)
		3.3.4平方阶	 O(n^2)
		3.3.5立方阶	 O(n^3)
-----------------------------------------------------------
描述			增长的数量级	说明		举例
-----------------------------------------------------------
常数级别		1				普通语句	将两个数相加
对数级别		logN			二分策略	二分查找
线性级别		N				循环		找出最大元素
线性对数级别	NlogN			分治思想	归并排序
平方级别		N^2				双层循环	检查所有元素对
立方级别		N^3				三层循环	检查所有三元组
指数级别		2^N				穷举查找	检查所有子集
-----------------------------------------------------------
O(1)< O(logn)< O(n)< O(nlogn)< O(n^2) < O(n^3)
-----------------------------------------------------------

4.函数调用的时间复杂度分析
	*第一步:分析被调用函数的时间复杂度
	*第二步:分析main方法调用函数的结构
	*第三步:把执行次数相加,得出时间复杂度

5.最坏情况:把最坏情况下的时间复杂度视为算法的时间复杂度

6.算法的空间复杂度
	6.1	数据类型			内存占用节数
		-------------------------
		byte			1
		short			2
		int				4
		long			8
		float			4
		double			8
		boolean			1
		char			2

	6.2	计算机访问内存的方式都是一次一个字节

	6.3	一个引用(机器地址)需要8个字节表示
			*例如 Date date = new Date();
			*date这个变量需要8个字节来表示

	6.4	创建一个对象，比如new Date()，除了Date对象内部存储的数据占用的内存外，该对象本身也有内存开销.
			*对象本身的内存开销用来保存对象的头信息
			*对象本身占用16个字节

	6.5	一般内存的使用，如果不够8个字节，都会被自动填充为8个字节。
		   *public class A {
				public int a = 1;
			}
			通过new A()创建一个对象的内存占用如下：
				1.对象本身占用16个字节
				2.变量a占用4个字节
			那么，创建该对象总共需要20个字节，但是20不是8的倍数，所以自动填充为24个字节。

	6.6	java中数组被限定为对象，他们一般都会因为记录长度而需要额外的内存，
		一个原始数据类型的数组一般需要24个字节的头信息，再加上保存值所需内存。
			*头信息:16个字节用于自身对象的开销，4个字节用于保存长度，4个字节自动填充

7.空间复杂度的具体分析
	*第一种算法
		*不管传入的数组大小为多少，始终额外申请4+4=8个字节
		*空间复杂度为O(1)
		public static int[] reverse1(int[] arr) {
			int n = arr.length;// 申请4个字节
			int temp;// 申请4个字节
			for (int start = 0, end = n - 1; start <= end; start++, end--) {
				temp = arr[start];
				arr[start] = arr[end];
				arr[end] = temp;
			}
			return arr;
		}

	*第二张算法
		*不管传入的数组大小为多少，始终额外申请28+n*4个字节
		*空间复杂度为O(n)
		public static int[] reverse2(int[] arr) {
			int n = arr.length;// 申请4个字节
			int[] temp = new int[n];// 申请24+n*4个字节
			for (int i = n - 1; i >= 0; i--) {
				temp[n - 1 - i] = arr[i];
			}
			return temp;
		}
	*结论：从空间占用角度来看，第一种算法要优于第二种算法